#!/usr/bin/sbcl --script

(let ((quicklisp-init (merge-pathnames "quicklisp/setup.lisp"
                                       (user-homedir-pathname))))
  (when (probe-file quicklisp-init)
    (load quicklisp-init)))

(with-output-to-string (*standard-output*)
  (ql:quickload :ironclad)
  (ql:quickload :s-base64))

;; helper functions
(defun split (string &key (remove-if-empty t))
  (let ((tokens
         (loop for i = 0 then (1+ j)
            as j = (position #\Space string :start i)
            collect (subseq string i j)
            while j)))
    (if remove-if-empty
        (remove-if (lambda (s) (equalp s "")) tokens)
        tokens)))

(defun read-number ()
  (parse-integer (read-line)))

(defstruct node (color nil) (tr nil) (tl nil) (bl nil) (br nil))

(defun build-tree (string)
  (let ((index 0))
    (labels ((parse-node (node)
               (when (not (node-color node))
                 (case (schar string index)
                   ((#\b) (setf (node-tr node) (make-node :color :b)))
                   ((#\w) (setf (node-tr node) (make-node :color :w)))
                   (otherwise (setf (node-tr node) (make-node))))
                 (incf index)
                 (case (schar string index)
                   ((#\b) (setf (node-tl node) (make-node :color :b)))
                   ((#\w) (setf (node-tl node) (make-node :color :w)))
                   (otherwise (setf (node-tl node) (make-node))))
                 (incf index)
                 (case (schar string index)
                   ((#\b) (setf (node-bl node) (make-node :color :b)))
                   ((#\w) (setf (node-bl node) (make-node :color :w)))
                   (otherwise (setf (node-bl node) (make-node))))
                 (incf index)
                 (case (schar string index)
                   ((#\b) (setf (node-br node) (make-node :color :b)))
                   ((#\w) (setf (node-br node) (make-node :color :w)))
                   (otherwise (setf (node-br node) (make-node))))
                 (incf index)
                 (parse-node (node-tr node))
                 (parse-node (node-tl node))
                 (parse-node (node-bl node))
                 (parse-node (node-br node)))))

      (case (char string 0)
        (#\b (make-node :color :b))
        (#\w (make-node :color :w))
        (otherwise
         (incf index)
         (let ((node (make-node)))
           (parse-node node)
           node))))))

(defun find-depth (tree)
  (labels ((depth (node)
             (if (node-color node)
                 1
                 (1+ (max (depth (node-tr node))
                          (depth (node-tl node))
                          (depth (node-bl node))
                          (depth (node-br node)))))))
    (depth tree)))

(defun print-depth (tree)
  (with-output-to-string (*standard-output*)
    (labels ((rec (node i)
               (if (node-color node)
                   (progn (princ i) (princ " "))
                   (progn
                     (rec (node-tr node) (1+ i))
                     (rec (node-tl node) (1+ i))
                     (rec (node-bl node) (1+ i))
                     (rec (node-br node) (1+ i))))))
      (rec tree 0))))

(defun expand-tree (tree &optional depth)
  (let ((d (1- (or depth (find-depth tree)))))
    (labels
        ((expand (node i)
           (when (< i d)
             (when (node-color node)
               (setf (node-tr node) (make-node :color (node-color node)))
               (setf (node-tl node) (make-node :color (node-color node)))
               (setf (node-bl node) (make-node :color (node-color node)))
               (setf (node-br node) (make-node :color (node-color node)))
               (setf (node-color node) nil))
             (expand (node-tr node) (1+ i))
             (expand (node-tl node) (1+ i))
             (expand (node-bl node) (1+ i))
             (expand (node-br node) (1+ i)))))
      (expand tree 0))
    tree))

(defun sum-trees (t1 t2)
  (cond
    ((and (node-color t1) (node-color t2))
     (if (or (eq (node-color t1) :b)
             (eq (node-color t2) :b))
         (make-node :color :b)
         (make-node :color :w)))
    ((node-color t1)
     (if (eq (node-color t1) :b)
         (make-node :color :b)
         t2))
    ((node-color t2)
     (if (eq (node-color t2) :b)
         (make-node :color :b)
         t1))
    (t
     (make-node :tr (sum-trees (node-tr t1) (node-tr t2))
                :tl (sum-trees (node-tl t1) (node-tl t2))
                :bl (sum-trees (node-bl t1) (node-bl t2))
                :br (sum-trees (node-br t1) (node-br t2))))))

(defun print-tree (tree)
  (with-output-to-string (*standard-output*)
    (labels ((print-node (node i)
               ;; (when (node-color node))
               ;; (when node
               ;;   (princ (case (node-color node)
               ;;            ((:b) #\b)
               ;;            ((:w) #\w)))))
               (when node
                 (if (node-color node)
                     (princ (case (node-color node)
                              ((:b) #\b)
                              ((:w) #\w)))
                     (princ #\p))))
             ;; (if (node-color node)
             ;;     (progn
             ;;       (if (> d i)
             ;;           (format t "~dx" (expt 4 (- d i)))
             ;;           (format t "K"))
             ;;       (princ (case (node-color node)
             ;;                ((:b) #\b)
             ;;                ((:w) #\w))))
             ;;     (princ #\p))))
             (print-aux (tree i)
               (when tree
;                 (print-node tree i)
                 (when (node-tr tree)
                   (print-node (node-tr tree) i)
                   (print-node (node-tl tree) i)
                   (print-node (node-bl tree) i)
                   (print-node (node-br tree) i))
                 (print-aux (node-tr tree) (1+ i))
                 (print-aux (node-tl tree) (1+ i))
                 (print-aux (node-bl tree) (1+ i))
                 (print-aux (node-br tree) (1+ i)))))
      (print-node tree 1)
      (print-aux tree 0))))

(defun print-zoom (tree n d)
  (labels ((rec (node i)
             ;; (if node
             ;;     (let ((newacc (if (> i n)
             ;;                       (progn
             ;;                         (cons (print-map tree) acc))
             ;;                       acc)))
             ;;       (rec (node-tr node) (1+ i) newacc)
             ;;       (rec (node-tl node) (1+ i) newacc)
             ;;       (rec (node-bl node) (1+ i) newacc)
             ;;       (rec (node-br node) (1+ i) newacc))
             ;;     acc)))
             (when node
               (when (= i n)
                 (return-from print-zoom (print-map2 node d)))
               (let* ((node-list (list (node-tr node)
                                       (node-tl node)
                                       (node-bl node)
                                       (node-br node)))
                      (depth-list (mapcar (lambda (n) (find-depth n)) node-list))
                      (max (apply #'max depth-list)))
                 (rec (nth (position max depth-list) node-list) (1+ i))))))
                 ;; (rec (node-tr node) (1+ i))
                 ;; (rec (node-tl node) (1+ i))
                 ;; (rec (node-bl node) (1+ i))
                 ;; (rec (node-br node) (1+ i))))))
    (rec tree 0)))

(defun print-map (tree &optional depth)
  (let* ((d (or depth (find-depth tree)))
         (size (floor (expt 4 (/ (1- d) 2))))
         (a (make-array (list size size) :initial-element :w)))
    (labels ((print-node (node x y i)
               (when (>= i 0)
                 (if (node-color node)
                     (setf (aref a (1- x) (1- y)) (node-color node))
                     (let ((s (expt 2 (1- i))))
                                        ;                     (print (list x y))
                       (print-node (node-tr node) (- x s) y (1- i))
                       (print-node (node-tl node) (- x s) (- y s) (1- i))
                       (print-node (node-bl node) x (- y s) (1- i))
                       (print-node (node-br node) x y (1- i)))))))
      (print-node tree size size (- d 1)))
    (dotimes (i size)
      (dotimes (j size)
        (princ (coerce (aref a i j) 'character)))
      (terpri))
    ;a
    ))

(defun print-map2 (tree &optional depth)
  (let* ((d (or depth (find-depth tree)))
         (size (floor (expt 4 (/ (1- d) 2))))
         (a (make-array (list size size) :initial-element :n)))
    (labels ((print-node (node x y i color)
                 (if (zerop i)
                     (setf (aref a (1- x) (1- y)) (or (and node (node-color node)) color :n))
                     (let ((s (expt 2 (1- i)))
                           (c (or (and node (node-color node)) color)))
                       (print-node (and node (node-tr node)) (- x s) y (1- i) c)
                       (print-node (and node (node-tl node)) (- x s) (- y s) (1- i) c)
                       (print-node (and node (node-bl node)) x (- y s) (1- i) c)
                       (print-node (and node (node-br node)) x y (1- i) c)))))
      (print-node tree size size (- d 1) (and tree (node-color tree))))
;;     (dotimes (i size)
;;       (dotimes (j size)
;;         (write-byte (if (eq (aref a i j) :b) 0 255); (coerce (aref a i j)
;;                                         ; 'character)
;;                      *standard-output* 
;;                     ))
;; ;      (terpri)
;;       )
    a
    ))

(defun sum-squares (tree &optional d)
  (labels ((rec (node i)
             (cond
               ((zerop i) 0)
               ((not node) 0)
               ((eq (node-color node) :w) 0)
               ((eq (node-color node) :b) (expt 4 (1- i)))
               (t (+ (rec (node-tr node) (1- i))
                     (rec (node-tl node) (1- i))
                     (rec (node-bl node) (1- i))
                     (rec (node-br node) (1- i)))))))
    (rec tree (or d (find-depth tree)))))

(defun main ()
  (dotimes (i (read-number))
    ;; (format t "~d~%" (count #\w (print-tree (reduce #'sum-trees (mapcar #'build-tree (split (read-line)))))))))
    ;(format t "~a~%" (print-tree (expand-tree (reduce #'sum-trees (mapcar
                                        ;#'build-tree (split (read-line)))))))
;    (format t "~a~%" (print-tree (reduce #'sum-trees (mapcar #'build-tree
                                        ;    (split (read-line))))))
                                        ;    (format t "~a~%" (find-depth (build-tree (read-line))))

    (format t "~d~%" 4)))
    ;; (let ((tree (build-tree (read-line))))
    ;;   (dotimes (j (ceiling (/ (find-depth tree) 5)))
    ;;     (with-open-file (out (format nil "image-~d~d.data" i j) :direction :output :if-exists :supersede :element-type '(unsigned-byte 8))
    ;;       (let ((a (print-zoom tree (* j 5) 10)))
    ;;         (dotimes (i (array-dimension a 0))
    ;;           (dotimes (j (array-dimension a 0))
    ;;             (write-byte (if (eq (aref a i j) :b) 0 255) out; (coerce (aref a i j)
    ;;                         )))))))))
    ;; (let* ((tree (print-tree (reduce #'sum-trees (mapcar #'build-tree (split (read-line))))))
    ;;        (n (parse-integer (concatenate 'string (mapcar (lambda (x) (if (char= x #\w) #\0 #\1)) (concatenate 'list (remove #\p tree)))) :radix 2)))
    ;;   (format t "~a~%"
    ;;           #))))
;              (floor (/ (length (concatenate 'list (remove #\p tree))) 8))
              ;; (with-output-to-string (out)
              ;;   (s-base64:encode-base64-bytes (ironclad:integer-to-octets n) out))))))
    ;; (let ((tree (reduce #'sum-trees (mapcar #'build-tree (split (read-line))))))
    ;;   (dotimes (j 10)
    ;;     (with-open-file (out (format nil "island-out-~d-~d.data" i j) :direction :output :if-exists :supersede)
    ;;       (let ((*standard-output* out))
    ;;         (print-zoom tree j 11)))))))

(main)
